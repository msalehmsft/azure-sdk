### Authentication {#clang-implementing-auth}

When implementing authentication, don't open up the consumer to security holes like PII (personally identifiable information) leakage or credential leakage.  Credentials are generally issued with a time limit, and must be refreshed periodically to ensure that the service connection continues to function as expected.  Ensure your client library follows all current security recommendations and consider an independent security review of the client library to ensure you're not introducing potential security problems for the consumer.

~ MustNot {#clang-implementing-no-persistence-auth}
persist, cache, or reuse security credentials.  Security credentials should be considered short lived to cover both security concerns and credential refresh situations.  
~

If your service implements a non-standard credential system (one that is not supported by Azure Core), then you need to produce an authentication policy for the HTTP pipeline that can authenticate requests given the alternative credential types provided by the client library.

~ Must {#clang-implementing-auth-policy}
provide a suitable authentication policy that authenticates the HTTP request in the HTTP pipeline when using non-standard credentials.  This includes custom connection strings, if supported.
~

~ ToDo
The authentication policies are generally within the Azure Core library - that does not exist yet.
~

### Memory Management {#clang-memory-management}

~ Must 
design your APIs, so that the caller allocates the memory and passes it to the functions; e.g. `int az_iot_create_client(az_iot_client* client);`. 
The API caller could then write code similar to:

```c
az_iot_client client; /* or allocate dynamically with malloc() if needed */

/* init client, if needed */
client.id = 0; 
client.name = NULL;

if (az_iot_create_client(*client) != 0)
{
    /* handle error */
}
```
~

~ Should 
consider adding an option  be to pass functions to allocate/deallocate memory as needed. This is similar to the threadx style; e.g.

```c
/* In this example, both allo and free are used in the same struct, but it's possible to use only one */
typedef struct az_alloc_callbacks {
    void* (*allocate)(size_t);
    void (*free)(void*);
} az_alloc_callbacks;

az_iot_client *az_iot_create_client(az_alloc_callbacks *allocation_callbacks);
void az_iot_close_client(az_iot_client *client, az_alloc_callbacks *allocation_callbacks);

/* client code */
int test() {
    az_iot_client *client = az_iot_create_client(&(az_alloc_callbacks){.allocate = malloc, .free = 0});
    return client != NULL;
};
```
~

~ Should 
consider adding global functions to allocate and free memory. This example is from [Azure ulib-c guidelines](https://github.com/Azure/azure-ulib-c/blob/aff6c7769c6204f6160f4634e30c4fe9b8978db4/doc/code_style.md):

```c
/**
 * @brief   uLib malloc
 *
 *  Defines the malloc function that the ulib shall use as its own way to dynamically allocate
 *      memory from the HEAP. For simplicity, it can be defined as the malloc(size) from the `stdlib.h`.
 */
#define AZIOT_ULIB_CONFIG_MALLOC(size)    malloc(size)

/**
 * @brief   uLib free
 *
 *  Defines the free function that the ulib shall use as its own way to release memory dynamic 
 *      allocated in the HEAP. For simplicity, it can be defined as the free(ptr) from the `stdlib.h`.
 */
#define AZIOT_ULIB_CONFIG_FREE(ptr)       free(ptr)
```
~

### Using Secure Functions {#clang-memory-management}
~ ShouldNot
use [Microsoft security enhanced versions of CRT functions](https://docs.microsoft.com/en-us/cpp/c-runtime-library/security-enhanced-versions-of-crt-functions?view=vs-2019() to implement APIs that need to be portable across many platforms. Such code is not portable and is not C99 compatible. Adding that code to your API will complicate the implementation with little to no gain from the security side. See [arguments against]( http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1967.htm). 
~

~ ToDo 
Verify with securty team, and what are the alternatives.
~

